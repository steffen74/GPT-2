
1 Introduction
As logistic networks get larger and larger and more and
more complex, they become more difﬁcult to handle and to
control. The traditional central control does not work
ﬂexibly and efﬁciently enough in any case so that one must
look for alternative approaches. This applies particularly if
the logistic network may change dynamically. One of the
most signiﬁcant current paradigms that faces this complexity is the so-called autonomous control approach (cf.
[11]). This approach proposes that each logistic object such
as a container or an automated guided vehicle receives its
own computing processor and makes its decision autonomously. Therefore, the components can react locally and
quickly to changes in the environment. However, a major
challenge within this kind of decentralized approach is how
the individuals act and cooperate with each other to reach a
desired global goal. In this paper, we introduce and discuss
graph-transformational swarms as a formal modeling
approach to dynamic logistic networks with decentralized
control. As an illustrative example, we consider and discuss the routing problem of automated guided vehicles.
The concept of graph-transformational swarms combines the ideas of swarm computing and the methods of
graph transformation. The basic framework is introduced in
[1], where a simple ant colony, cellular automata, and
discrete particle systems are modeled to demonstrate the
usefulness and ﬂexibility of the approach. A graph-transformational swarm consists of members that act and
interact simultaneously in an environment, which is represented by a graph. The members are all of the same kind
or of different kinds. Kinds and members are modeled as
graph-transformational units (see, e.g.,[15]); each unit
consists of a set of graph-transformational rules specifying


the capability of members and a control condition which
regulates the application of rules.
This paper is organized as follows. In Sect. 2, graphtransformational swarms are recalled starting with the basic
concepts of graph transformation. Section 3 discusses how
graph-transformational swarms can be used to model
dynamic logistic networks. To illustrate this, essential
aspects of the routing problem of automated guided vehicles are modeled as graph-transformational swarms in
Sect. 4. Section 5 concludes the paper.

2 Graph-transformational swarms
This section recalls the concept of graph-transformational
swarms as introduced in [1] starting with the basic components of the chosen graph-transformational approach as
far as needed in this paper (for more details, see, e.g.,
[8, 14, 16, 20]).
2.1 Basic concepts of graph transformation
2.1.1 Graphs and rules
A (directed edge-labeled) graph G ¼ ðV; E; s; t; lÞ consists
of a set V of nodes, a set E of edges such that every edge is
directed and labeled, i.e., s : E ! V and t : E ! V are
mappings assigning a source s(e) and a target t(e) to each
e 2 E and l : E ! R is a labeling function for some
labeling alphabet R. If the target is equal to the source, then
the edge is called a loop. In the following, we call a node
an i-node if it has an i-loop for i 2 R. The components V,
E, s, t, and l of G are also denoted by VG , EG , sG , tG , and lG ,
respectively.
Given
two
graphs
G ¼ ðV; E; s; t; lÞ
and
H ¼ ðV 0 ; E0 ; s0 ; t0 ; l0 Þ, a graph morphism g : G ! H is given
by two mappings gV : V ! V 0 and gE : E ! E0 such that
s0 ðgE ðeÞÞ ¼ gV ðsðeÞÞ, t0 ðgE ðeÞÞ ¼ gV ðtðeÞÞ and l0 ðgE ðeÞÞ ¼
lðeÞ
for
all
e 2 E.
The
image
gðGÞ ¼
ðgV ðVÞ; gE ðEÞ; s00 ; t00 ; l00 Þ where s00 ,t00 and l00 are restrictions
of s0 , t0 and l0 to the subsets gE ðEÞ and gV ðVÞ is called a
match of G in H. If gE and gV are inclusions, G is called a
subgraph of H, denoted by G  H. In particular, a match of
G in H is a subgraph. It should be noted that the graph
morphisms yielding matches are not assumed to be
injective.
A rule r ¼ ðL; K; RÞ consists of three graphs, the lefthand side L, the gluing graph K, and the right-hand side R
such that L  K  R. In this paper, we consider rules that
manipulate only edges (i.e., the nodes are neither deleted
nor added). And when depicted, the gluing graph is omitted
using the same relative positions of nodes in L and R. The
edges in L and R that have the same sources, targets, labels,

123

Logist. Res. (2016) 9:20

and form are also not changed by the rules. K can be
identiﬁed in this way as the identical parts of L and R.
In order to permit more ﬂexibility in modeling, we
consider in this paper rules with negative application
conditions. This extends the notion of rules permitting to
express what should not be present in a graph in order to
apply a given rule. A rule with negative application condition r ¼ ðN; L; K; RÞ consists of four components such
that (L, K, R) is a rule and N is the associated negative
application condition composed from a ﬁnite set of graphs
N ¼ fC1 ; . . .; Ck g called each a negative context such that
L & Ci for i 2 ½k. Every negative context speciﬁes a negative part Ci À L which consists of the items of Ci that do
not belong to L.
We depict a rule r ¼ ðN; L; K; RÞ with N ¼ fC1 ; . . .; Ck g
as N À R where N is represented as a graph with sub!
graph L and extra information such that the negative contexts are identiﬁed. In this representation, the dashed items
of N belong to the negative parts, the remainder is L. In one
case in Fig. 8, the negative part contains two edges which
are enclosed by a dotted line. In all other cases, the negative part contains a single edge. In this way, all negative
contexts are easily recognized
Figure 1 shows the rule move which is used in a modiﬁed form in Sect. 4 to model the movement of an automated guided vehicle with the name a having the target T
which is represented by an edge labeled by a, T. The
(T, d)-edge indicates the direction in which the target T can
be reached in the distance d. In this rule, there are two
negative contexts. The ﬁrst one is speciﬁed by the negative
part consisting of the dashed edge labeled by a00 ; T 00 and its
source node. It means that the vehicle a can move into the
new position only if there is no other (concurrent) vehicle
that can occupy the same next position. The second negative context is speciﬁed by the negative part that consists
of the dashed edge labeled by a0 ; T 0 requiring that the
vehicle a can move into the new position only if there is no
other vehicle present there. The gluing graph consists of
the three nodes and the edge labeled by T, d.
The application of a rule r ¼ ðL; K; RÞ to a graph G
replaces a match of L in G by R such that the match of K is
kept. More explicitly, let g : L ! G be the graph morphism
yielding the match g(L). Then, the resulting graph H is
obtained by removing gðLÞ À gðKÞ from G and adding
R À K. All edges keep theirs sources, targets, and labels
with the exception of edges in R À K with sources or


targets in K. If e 2 ER À EK with sR ðeÞ 2 VK (or
tR ðeÞ 2 VK ), then sH ðeÞ ¼ gV ðsR ðeÞÞ (or tH ðeÞ ¼ gV ðtR ðeÞÞ
resp.).
A rule with negative condition (N, L, K, R) with N ¼
fC1 ; . . .; Ck g is applied in the same way as (L, K, R) provided that, for i 2 ½k, the match of L cannot be extended to
Ci . This means that a rule can only be applied if none of its
negative contexts is around.
Hence, the application of the rule move moves forward
an (a, T)-edge (i.e., the target node becomes the source
node) provided that in the new position, there is no other
(a0 ; T 0 )-edge. And there is no other ða00 ; T 00 Þ-edge having
the same target node.
A rule application is denoted by G ¼ H where H is the
)
r

resulting graph and called a direct derivation from G to H.
As an example of a rule application, let us consider the
graph G with the explicitly given subgraph in Fig. 2 (The
dots in the graph indicate that the graph G may actually
contain more items than the depicted subgraph). There is
an (a, T)-edge meaning that the vehicle a has the target T.
Moreover, there are four edges ahead, but one is occupied
by vehicle a0 and another one is not accompanied by a
(T, d)-edge so that target T is not reachable with minimal
distance in this direction. Two options remain to complete
a match of the left-hand-side of rule move that avoid the
negative context. One is chosen non-deterministically to
derive the graph H where the vehicle a is moved forward
by one edge. Continuing in this way, the vehicle a will
reach its destination T eventually following always the
directions with minimal distance.
A sequence G ¼ G0 ¼ G1 ¼ Á Á Á ¼ Gm ¼ H is
)
)
)
r1

r2

rm

called a derivation from G to H of length m.
Given the rules ri ¼ ðNi ; Li ; Ki ; Ri Þ for i ¼ 1; . . .; n, the
parallel rule p ¼ ðL; K; RÞ is given by the disjoint unions
of the components, i.e., L ¼ ]n Li ; K ¼ ]n Ki ; R ¼
i¼1
i¼1
]n Ri . If gi : Li ! G for i ¼ 1; . . .; n are some graph
i¼1
morphisms from Li in some graph G, then this induces a
graph morphism g : L ! G deﬁned, for all i ¼ 1; . . .; n, by
gV ðvÞ ¼ gi;V ðvÞ for all v 2 VLi and gE ðeÞ ¼ gi;E ðeÞ for all
e 2 ELi . Therefore, matches of parallel rules are composed

20

of matches of their component rules. As we use parallel
rules only in this way, there is no need to carry the negative
application conditions over to the level of parallel rules.
Negative application conditions are only checked for
component rules.
)
Two direct derivations G ¼ H1 and G ¼ 0 H2 of rules r
)
r

r

and r 0 are (parallel) independent if the corresponding
matches intersect only in gluing items. Due to the parallelization theorem in [13], we can use the following fact: A
P
parallel rule p ¼ n ri can be applied to G if the rules ri
i¼1
for i ¼ 1; . . .; n can be applied to G and the matches are
pairwise independent. This allows the use of massive parallelism in the context of graph transformation based on
local matches of component rules which are much easier to
ﬁnd than matches of parallel rules.
2.1.2 Control conditions and graph class expressions
A control condition C is deﬁned over a ﬁnite set P of rules
and speciﬁes a set SEM(C) of derivations. Typical control
conditions are regular expressions over P. The regular
expressions have the form r for some rule r or e; e0 or eje0
or eÃ where e and e0 are regular expressions themselves.
The satisfaction of a control condition in the form of a
regular expression is deﬁned as follows. A direct derivation
applying r satisﬁes r. A derivation satisﬁes e; e0 if an initial
section of the derivation satisﬁes e and the rest e0 . It satisﬁes eje0 if it satisﬁes e or e0 . It satisﬁes eÃ if it satisﬁes en
for some n 2 N where e0 ¼ k and eðnþ1Þ ¼ en ; e. A
derivation of length 0 satisﬁes k. Alternatively to eÃ , e! is
used. A derivation satisﬁes e! if it satisﬁes en , but not
eðnþ1Þ , i.e., e is followed as long as possible. We use also
priority conditions of the form r \ r 0 requiring that r can
only be applied if r 0 is not applicable. Moreover, control
conditions can be combined by logical operations of which
we use the conjunction and with the obvious meaning:
C&C 0 are satisﬁed if C and C 0 are satisﬁed. The expression
eje0 can be restricted by the priority condition e \ e0 which
requires that e is applied only if e0 is not applicable. Other
examples of control conditions that are used in this paper

Fig. 2 A rule application

a ,T

a ,T
T, d

T, d

a, T
···

···
T, d

=⇒
move

···

T, d

G

···
T, d
T, d

a, T

H


are the expression krk and [r]. krk requires that a maximum number of rule r be applied in parallel. [r] requires
that the rule r may be applied or not.
A graph class expression X speciﬁes a set of graphs
denoted by SEMðXÞ. We use the graph class expressions
distance and idÀloopedðdistanceÞ. The set SEMðdistanceÞ
contains all graphs without loops and without parallel
edges (i.e., loop-free and simple graphs) where each edge is
labeled with a distance (i.e., a value d 2 N). The set
SEMðidÀloopedðdistanceÞÞ contains all graphs that are
obtained from the graphs in SEM(distance) as follows: The
nodes are numbered from 1 to the number of nodes, and
every node gets a loop labeled with its number. These
graphs are called id-looped distance graphs. While the
underlying distance graphs provide the signiﬁcant information, the id-loops are added for technical reasons
because they allow a direct access to nodes via rule
applications.
2.1.3 Graph-transformational units
A graph-transformational unit is a pair gtu ¼ ðP; CÞ where
P is a set of rules and C is a control condition over P. The
semantics of gtu consists of all derivations of the rules in P
allowed by C. A unit gtu0 is related to a unit gtu if gtu0 is
obtained from gtu by renaming identiﬁers and relabeling
edges. The set of units related to gtu is denoted by
RUðgtuÞ.
2.2 Graph-transformational swarms
A graph-transformational swarm consists of members of
the same kind or of different kinds. All members act
simultaneously in a common environment represented by a
graph. The number of members of each kind is given by the
size of the kind. While a kind is a graph-transformational
unit, the members of this kind are modeled as units related
to the kind so that all members of same kind are alike.
A swarm computation starts with an initial environment.
It consists of iterated rule applications requiring massive
parallelism meaning that each member of the swarm
applies one of its rules in every step. The choice of rules
depends on their applicability and the control conditions of
the members as well as on a cooperation condition.
Moreover, a swarm may have a goal given by a graph class
expression. A computation is considered to be successful if
an environment is reached that meets the goal.
Deﬁnition 1 (swarm) A swarm is a system S ¼
ðI; K; s; m; c; gÞ where I is a graph class expression specifying the set of initial environments, K is a ﬁnite set of
graph-transformational units, called kinds, s associates a
size sðkÞ 2 N with each kind k 2 K, m associates a family

123

Logist. Res. (2016) 9:20

of members ðmðkÞi Þi2½sðkÞ with each kind k 2 K with
mðkÞi 2 RUðkÞ for each i 2 ½sðkÞ, c is a control condition
called cooperation condition, and g is a graph class
expression specifying the goal.1
A swarm may be represented schematically displaying
the components initial, kinds, size, members, cooperation,
and goal followed by their respective values.
Deﬁnition 2 (swarm computation) A swarm computation
is a derivation G0 ¼ G1 ¼ Á Á Á ¼ Gq
)
)
)
such that
p
p
pq
P 1 P 2
G0 2 SEMðIÞ, pj ¼ k2K i2½sðkÞ rjki with a rule rjki of
mðkÞi for each j 2 ½q, k 2 K and i 2 ½sðkÞ, and c and the
control conditions of all members are satisﬁed. The computation is successful if Gq 2 SEMðgÞ.
That all members must provide a rule to a computational
step is a strong requirement because graph-transformational rules may not be applicable. In particular, if no rule
of a swarm member is applicable to some environment, no
further computational step would be possible and the
inability of a single member stops the whole swarm. To
avoid this global effect of a local situation, we assume that
each member has the empty rule ð;; ;; ;; ;Þ in addition to
its other rules. The empty rule gets the lowest priority and
is only applied if no other rule of the member can be
applied or is allowed by the control condition of the
member or the cooperation condition of the swarm. In this
way, each member can always act and is no longer able to
terminate the computation of the swarm. In this context, the
empty rule is called sleeping rule. It can always be applied,
is always parallel independent with each other rule application, but does not produce any effect. Hence, there is no
difference between the application of the empty rule and no
application within a parallel step.

3 From swarms in nature to logistic networks
as graph-transformational swarms
In this section, we argue that graph-transformational
swarms as introduced in the previous section are appropriate means to model dynamic logistic networks. Several
approaches to swarm computation including graph-transformational swarms mimic swarms in nature as pointed
out in Sect. 3.1 in more detail. The interesting aspect is that
already swarms in nature solve problems closely related to
logistics. Moreover and more interesting in the context of
this paper, a closer look the other way round at dynamic
logistic networks in Sect. 3.2 reveals that they can be
considered as graph-transformational swarms.
1


20

3.1 Relating swarms in nature with logistics

Table 1 Correspondence between dynamic logistic networks and
graph-transformational swarms

The proposed framework is inspired by the swarm behavior
in nature which describes the group behavior of social
animals. Several studies agree on the assumption that the
swarm behavior results from relatively simple rules on the
individual level (see, e.g., [4–6, 19]). In biology, the
underlying mechanism is also known as self-organization:
The individuals in the group interact locally with other
group members and have no knowledge of the global
behavior of the entire group. Furthermore, all members
play the same role without any hierarchical structure [4].
Using swarm behavior, social animals solve continuously complex problems. For instance, ant colonies as well
as bee hives build nests and manage the resources inside it.
Furthermore, they forage for food, transporting it in an
efﬁcient and ﬂexible way. Schools of ﬁshes and ﬂocks of
birds travel over long distances. Obviously, such phenomena have logistic aspects. Therefore, it is somewhat evident
that the behavior of swarms in nature inspires to introduce
concepts of artiﬁcial swarms and swarm computation that
are based on the idea of self-organization to solve logistic
problems. One encounters some approaches to swarm
computation in the literature (see, e.g., [2, 3, 9, 12, 18])
where logistic problems are solved as typical examples like
the shortest path problem, the traveling-salespersons problem and others. One may summarize that the passage from
swarms to logistics is not very long.

Dynamic logistic network

Graph-transformational
swarm

Underlying structure

Environment graph

3.2 Dynamic logistic networks as graphtransformational swarms
On the other hand, consider dynamic logistic networks.
Their underlying structures consist of nodes and connecting
edges. The nodes represent logistic hubs of different types
such as production sites, storage facilities, and car pools
or—on a more detailed level—packages, containers, cars,
and trucks, and the edges represent transport lines or
information channels or the like. Without loss of generality, one can assume that there is always some start structure. To manage the material and information ﬂows in a
logistic network, various logistic processes are running. If
the network is large and widely distributed, then it may not
be meaningful to control the processes centrally. Alternatively, the logistic processes in the network may run
simultaneously and independently of each other each performing its own actions and following its own autonomous
control. But such a decentralized control requires coordination and cooperation whenever material or information
must be exchanged carrying out the overall tasks. To
coordinate autonomous logistic processes in a network in
such a way that the cooperation works properly, becomes
even more difﬁcult if the network structure is dynamically

Types of logistic entities

Kinds

Logistic entities
Possible actions

Members
Rules

Autonomous control

Control conditions

Start structures

Initial environments

Coordination

Cooperation conditions

Tasks

Goals

Simultaneous and decentralized
processing

Massively parallel rule
application

changing. One needs appropriate modeling methods like
those provided by graph-transformational swarms.
The underlying structures of dynamic logistic networks
are deﬁned as graphs so that they correspond directly to
environment graphs of graph-transformational swarms
where the initial environments play the role of the start
structures. The various types of logistic entities like hubs,
sites, carriers, and containers together with the actions that
are performed on them or affect them can be seen as kinds
so that the entities themselves are the swarm members. In
particular, the possible process actions correspond to the
rules, and the autonomous control is reﬂected by the control conditions. Finally, the coordination of the processes
running on the logistic networks is embodied by the
cooperation conditions and the overall tasks by the goals.
Summarized in Table 1, there is a very close relationship
between the main features of dynamic logistic networks
and the syntactic components of graph-transformational
swarms. Moreover and most interestingly, the idea of
autonomous processes that run simultaneously and decentralized in a logistic network is well reﬂected on the
semantic level of graph-transformational swarms as all the
members act always in parallel.
3.3 The potentials of the approach
We propose in this paper to model dynamic logistic networks by means of graph-transformational swarms. In the
previous subsection, one can see that the notion of such
swarms covers all the main features one expects and ﬁnds
in dynamic logistic networks. Nevertheless, one may
wonder which particular potentials and advantages this
approach provides:
1.

The concept of graph-transformational swarms offers a
formal framework with a precise mathematical semantics based on massive parallelism of rule applications.


2.

As the environments are graphs and the processing is
modeled by graph-transformational rules speciﬁed by
four graphs each, the approach provides a fundament
for visualization so that it can be considered as a visual
modeling approach.
In fact, graph-transformational swarms can be executed
on graph-transformational engines like GrGen.NET
(see [10]) or AGG (see [23]) so that visual simulation is
possible for illustrations, tests, and experiments of
various kinds. In the next section for example, we use
illustrations in Figs. 5 and 9 generated from GrGen.NET. They visualize the computational steps in a
simple environment in order to make it easier for a
reader to understand how the developed swarm
behaves. Moreover, the implementation in GrGen.NET
allows us a visual testing using different graphs.
The formal semantics is based on derivations which are
sequences of rule applications. Therefore, a proof
technique is provided by induction on the lengths of
derivations.
If one ﬁxes the initial environment and bounds the
lengths of derivations, then the behavior of graphtransformational swarms can be translated into formulas of the propositional calculus so that SAT-solvers
can be employed for automatic proving of properties,
as far as they are expressible in propositional calculus.
A typical correctness property one would like to prove
in this way is: Will the goal be reached? Another
property of interest that can be proved in this way is
deadlock freeness.
The approach is very ﬂexible and generic because all
the modeling concepts can be chosen from a variety of
possibilities. This applies to the kind of graphs which
may be directed or undirected, labeled or unlabeled,
connected, simple, etc. It applies similarly to the kind of
rules, of control conditions and of graph class expressions. The actual choice may depend on the application
at hand or the taste of the network designers.
Graph-transformational swarms do not need extra
features to make logistic networks dynamic, i.e., to
allow the modeling of dynamic changes in the
underlying structure. The members of the swarm
perform their tasks by applying rules to the environment graph. This includes the possibility of members
to change the environment structurally.

3.

4.

5.

6.

7.

4 Routing of AGVs by a graph-transformational
swarm
In this section, we propose a solution to the routing problem of the automated guided vehicles (AGVs) using the
notion of graph-transformational swarms. Automated

123

Logist. Res. (2016) 9:20

guided vehicles are driverless transportation engines that
follow traditionally guide paths like lines on the ground.
Their use is expanding rapidly in the last decades. Beside
the classical application in small manufacturing systems,
nowadays, the tendency is to use AGVs more and more for
transport in highly complex systems including external
areas like container terminals (for a general overview, see,
e.g., [17, 26]). One of the important problems that a
designer of an AGV system faces in complex areas is the
collision-free routing problem. The classical way to solve
this problem is the central time windows planning (see,
e.g., [22, 24, 25]). However, the tendency in the last years
is to explore more decentralized approaches (e.g., [21, 27]).
In the same vein, this section proposes a decentralized
solution using the notion of graph-transformational
swarms.
4.1 The routing swarm
We model the infrastructure where the AGVs operate as an
idÀlooped distance graph. In a graphical representation,
the nodes correspond to the ends or intersections of paths
including important stations like pickup and delivery
locations. The edges represent the paths or segments of
paths in the infrastructure depending on their lengths. The
distance of an edge can correspond to the distance of the
corresponding path or to some cost of traversing it.
We propose a solution based on two stages. The ﬁrst one
consists of the preparation of the layout in a such way that
the AGVs follow later only local information. The second
one consists of the navigation process of the AGVs
depending on an arbitrary task assignment.
The parameter m is the number of AGVs and can be
chosen freely. The swarm has four kinds: preparator, resolver, assigner, and navigator. Their sizes are n,n, m, and
m, respectively, where n is the number of nodes in the
underlying graph G 2 SEMðidÀloopedðdistanceÞÞ. The
members are obtained by relabeling in such a way that
every node in the graph gets assigned two members, one of
kind preparator and the other of kind resolver, and similarly, every AGV gets assigned a member of kind assigner
and a member of kind navigator. How relabeling is
achieved is described below in the detailed introduction of
the kinds. Syntactically, the cooperation condition is a
regular expression as introduced in Sect. 2.1.2, but for
kinds instead of rules. Semantically, the used cooperation
condition requires that preparator is applied realizing the
layout preparation followed by an arbitrary repetition of
assignments each followed by an arbitrary number of
conﬂict resolving and navigation steps. The application of a
kind means that all members of this kind act in parallel
according to theirs’ own control conditions while all other
kinds :
size :
members:

coop:
goal:

id-looped(distance)
preparator,resolver,assigner,navigator
n = #nodes,n,m,m
preparatori for i ∈ [n]
resolverj for j ∈ [n]
assignerk for k ∈ [m]
navigatorl for l ∈ [m]
preparator; (assigner; (resolver; navigator)∗ )∗
all vehicles arrived

Fig. 3 Schematic representation of the graph-transformational swarm
routing

default. The goal is that all AGVs reach their assigned
targets. The swarm is schematically presented in Fig. 3.
As mentioned before, we have implemented the swarm
routing in the graph-transformational tool GrGen.NET.
The resulting computation steps of an experiment with an
environment composed from a very small graph, and three
AGVs are used in this section to accompany the explanation of the behavior of the swarm routing. Fig. 5 summarizes the layout preparation process, and Fig. 9 illustrates
the remainder of the computation which consists of the
assignment and the conﬂict-free navigation of the AGVs.
4.2 Layout preparation
The layout preparation equips the underlying graph with
additional edges in such a way that every node in the graph
can indicate to an AGV having the target T which next
node can be visited to reach T with the minimal distance
possible. Given an i-node, we code such an indicator as an
outgoing edge e labeled with a pair T, D. We say that i has

Page 7 of 13

20

an indicator to T with the distance D using the successor s,
where s is the target of e (i.e., s ¼ tðeÞ). If D is minimal
considering simple paths up to the maximal lengths l, we
say that the indicator is l-minimal. If D is minimal considering all possible paths, then the indicator is optimal. A
path composed from indicators to a target T is called an
indicator path to T. If every node in the graph has only
optimal indicators to every reachable node, then the graph
is called fully indicated.
The members of kind preparator realize the layout
preparation process. The kind preparator speciﬁed in Fig. 4
initializes this process with rule init. It adds an indicator in
an X-node to a direct successor s provided that such indicator does not yet exist. The rule connect connects an Xnode with an existing indicator path to T. It is applied if a
direct successor s of X exists having an indicator to T with a
distance D1 provided that there is no other direct successor
of X having the same target T with a distance D2 such that
D2 \ D1 þ d. The rule connect generates an indicator to T
with the new distance D1 þd using the successor s. If an Xnode has two indicators to a target T with different distances, the rule select deletes the one with the larger distance selecting in this way the best one to be kept. The
control condition requires that the rule init is applied with
maximum parallelism. Afterward, the rule connect is
applied followed by select both with maximum parallelism.
Because of the negative application condition of init, init is
applied only once for a given successor node in the whole
swarm computation while connect and select are iterated as
long as possible according to the control condition of
preparator.

Fig. 4 Unit preparator


Logist. Res. (2016) 9:20

Fig. 5 A sample computation
of the swarm routing illustrating
the layout preparation process

p1

p2

p3

p4

In the swarm, there are n members of kind preparator.
The member preparatori for i 2 ½n is obtained from
preparator by relabeling all occurring X with i.
Then i becomes a ﬁxed label in preparatori . The role of
the other labels must be explained now: They are placeholders for all possible values so that the rules are rather
rule schemata that must be instantiated before they are
applied. A control condition like ||init|| means accordingly
that the maximum number of the instantiations of the rule
init must be applied in parallel. This mechanism that keeps
the representation of rule sets small is used in all our
examples of transformation units.
In the following, we describe how the members work
together using the computation in Fig. 5 as illustrating
example. In the ﬁrst step, all members apply the rule init in
parallel generating in every node indicators to all successor
nodes (see the result of the derivation p1 in the example). In
the second step, the parallel application of the rule connect
in parallel connects all nodes to construct indicator paths of
length 2. It connects also those that are already connected
to indicator path of length 1 if the new distance is smaller,
then the old one (in the example, p2 adds indicators in the
nodes 2 and 3). In the third step, all members apply select
in parallel deleting all indicators using path of lengths 2

123

and 1 that are not 2-minimal (p3 deletes the indicator in 2 to
1 with distance 3 keeping the minimal indicator to 1 with
distance 2). Note that a node can have more than one
minimal indicator to the same target (in the example, the
node 3 gets two indicators to 1 with the same distance 4).
By induction, one can prove that in 2L À 1 steps, all Lminimal indicators are constructed. If the longest path with
a minimal distance is constructed, then the preparatormembers cannot apply any rule anymore (except the
sleeping rule). And the constructed indicators are optimal.
Because the length of such a path is shorter or equal n À 1,
the number of steps is bounded by 2n À 3. Summarizing,
the following correctness result holds:
Theorem 1 Given an id-looped distance graph G, the
swarm routing transforms it by the initial preparation
phase in a fully indicated graph in a number of steps
bounded by 2n À 3 where n is the number of nodes in G.
Note that the layout preparation process can be considered as a distributed version of the Dijkstra’s shortest
path algorithm (cf. [7]).
The behavior of the swarm in the layout preparation
stage can also be interpreted as follows. In the ﬁrst step, a
information over all nodes combining the rules connect and
select of all members of kind preparator. In more sophisticated versions of the underlying swarm, one can consider
that additional changes can occur in the environment like
suppression of indicator edges. This can simulate for
example a trafﬁc congestion. Such a change can be also
handled in the same way by propagating the information
backward to all concerned members. For illustration purposes, we keep the preparation process simple and show in
the next subsection how the automated guided vehicles can
use the generated information to navigate conﬂict-free to
their assigned targets.
4.3 Assignment, conﬂicts resolving, and navigation
The kinds assigner and navigator model the task assignment and navigation process from the point of view of the
AGVs. However, the task assignment has the most simple
form serving solely the simulation purposes of the computational steps. The kind resolver models the conﬂict
resolving from the point of view of a node where multiple
AGVs have it as next destination and would like to visit the
same next position which is determined by a direct successor of the underlying node.
In the following, we encode an AGV as an AGV-edge
labeled by a, T, p where a is the name of the AGV, T 2 ½n
corresponds to its assigned target and p 2 N is its current
priority. We call therefore a vector of nodes hn1 ; n2 i, such
that an indicator (T, d) from n1 to n2 exists, an AGV
position. We consider that AGVs with target T can occupy
such position with the restriction that at most one AGV can
be present in a position in a given time. The priority is
needed to resolve conﬂicts if more than one AGV compete
for one position.
The kind assigner, as speciﬁed in Fig. 6, has just a single
rule assign that creates a vehicle edge labeled with
a, T, p between two arbitrary nodes provided that this
position leads to the target T and is free and that the vehicle
edge is not yet present in the whole graph. Note that the
edges labeled by T, d in the rule assign have different
forms meaning that they do not belong to the gluing graph
of the rule. The control condition [assign] requires that the
rule may be applied or not so that not every vehicle must be
present any time. The members assignerj for j 2 ½m are
obtained from the kind assigner by relabeling all occurring
a with aj and the a0 by ak for j 6¼ k.
The kind resolver has a single rule reserve (see Fig. 7).
It reserves for an incoming AGV-edge labeled by a, T, p a
next possible position hX; si having an indicator T, d provided that the following four negative contexts are all
satisﬁed. (1) There is no other concurrent AGV (represented in the rule by the incoming AGV-edge a1 ; T1 ; p1 )

Page 9 of 13

20

with a higher priority ðp1 [ pÞ, and can visit too the
position hX; si ( see the edge ðT1 ; d1 Þ in the rule). This
negative context with two edges is bordered by a dotted
line to indicate that the two parts should be satisﬁed
together. (2) The position hX; si is free: There is no other
outgoing AGV-edge labeled by a2 ; T2 ; p2 parallel to the
(T, d)-edge. (3) There is no reservation a3 for any other
vehicle in the next position hX; si. (4) The AGV a has not
yet a reservation: There is no outgoing edge labeled by
a. The rule reserve adds an outgoing edge labeled by
a parallel to the (T, d)-edge which indicates that the
underlying position is reserved for the AGV a. The rule
reserve may be applicable for two AGVs with the same
priority both claiming the same next possible position
hX; si. But the control condition requires that the rule is
applied sequentially as long as possible so that only one of
the potential reservations is chosen non-deterministically.
The member resolverj for j 2 ½n is derived from resolver
by relabeling all occurring X with j. This means in particular that reservations are done sequentially at the node
with the j-loop, but in parallel for different nodes.
The kind navigator, which is speciﬁed in Fig. 8, contains three rules wait, move, and arrive. The rule wait
increments the priority p with 1. The rule move is
responsible of the forward movement of the AGV until the
target is reached. It moves forward the AGV a with the
target T following an a-edge (which is added by a resolver
member). If the target node is reached, the rule arrive can
be applied. The rule arrive deletes the AGV-edge signaling
in this way to the task assigner that the AGV a is free for a
new assignment. The control condition requires that one of
the rules move, arrive, or wait is applied. Therefore, wait
has the lowest priority. The member navigatork for k 2 ½m
is obtained from navigator by relabeling all occurring
a with ak .
After the layout preparation, only members of kind assigner, resolver, and navigator are active. The assigner
members create an arbitrary number less or equal m of
AGV-edges in parallel. According to the parallelization
theorem together with the fact that the T, d edges in the
rule assign do not belong to the gluing graph, the positions
of the created AGVs are pairwise different ensuring a
conﬂict-free assignment. Afterward, all created AGVedges act in parallel by moving forward or waiting
depending on the decision of the resolver members, which

Fig. 6 Unit assigner


Logist. Res. (2016) 9:20

Fig. 7 Unit resolver

m ¼ 0, no car moves so that no collision can happen. Let
now the computation have mþ1 assign-steps. Due to the
induction hypothesis, the vehicles run collision-free for the
ﬁrst m assign-steps. The ðmþ1Þ-st assign-step adds some
further AGVs, but only if none of these is already present
and the edges where the vehicles are assigned are not
occupied. All further steps are applications of the rule reserve alternated with the applications of the rules wait,
move, and arrive. A collision would only happen whenever
two AGVs move onto the same edge at the same time. But
such collision is impossible because the entered edge is
reserved before by exactly one vehicle as discussed in
detail above in the explanations of the kinds.
h

Fig. 8 Unit navigator

are present in every node to check for and to resolve
conﬂicts. They reserve the next possible position of the
AGVs based on their priorities. The AGVs with a reservation are moved forward setting their priorities to one, the
others that arrive to their targets become their corresponding edge deleted, all others have to wait incrementing
their priorities by one. If the number of repetition is high
enough, the swarm reaches its goal, otherwise the process
starts again by assigning new tasks to inactive vehicles.
The swarm repeats this process until the goal is reached.
Especially, we have the following result.
Theorem 2 If the swarm routing reaches its goal, each
AGV that has been assigned to a target reaches this target
collision-free.
Ã

Proof Consider a computation G0 ¼ Gn of the swarm
)
routing. According to the cooperation condition, an initial
Ã

section G0 ¼ Gi for some i prepares the initial environ)
ment G0 into a graph with the properties stated in TheoÃ

)
rem 1. And the tail Gi ¼ Gn is composed from sections of
Ã

)
)
the form Gkj ¼ Gkj þ1 ¼ Gkjþ1 for i ¼ k1 \ Á Á Á \km ¼ n,
m ! 1 where, for j ¼ 1; . . .; m, the ﬁrst step is an assignstep and the remainder repeats resolver-steps followed by
navigator-steps. For m ¼ 0, this is the empty sequence.
Then, the theorem can be proved by induction on m. For

123

The swarm routing is designed to solve conﬂict-free
situations where two or more concurrent AGVs want to
traverse the same node. However, it should be mentioned
that the presented swarm does not handle deadlocks caused
from circular waits. The characterization, detection, and
avoidance of such situations should be treated in future
work.
Figure 9 illustrates the computations in the navigation
process of three AGVs a1 ,a2 and a3 starting with the fully
connected graph resulting from the preparation process in
Fig. 5. In the ﬁrst step in this stage, two AGVs are arbitrarily chosen to get assignments and the reminder is kept
inactive. a1 and a3 get assigned, respectively, the targets 1
and 4 and the start positions h3; 1i and h3; 2i as a result of
the application of the rule p5 ¼ assign1 þ assign3 þ sleep2
where the indices in the rules correspond to the indices of
the members that apply them. After the assignment, the
member resolver2 which resolves conﬂict in node 2
reserves the next position for the AGV a3 through generating an a3 -edge while all other members of kind resolver
apply their sleeping rule, i.e., p6 ¼ reserve2 þ
P
i2½5nf2g sleepi . The rule p7 ¼ arrive1 þ move3 þ sleep2 is
applied making a1 available for other assignments because
it has already arrived at its target and moving forward the
vehicle a3 to its reserved position. The AGV a2 is still

p5

20

p6

p7

p9

p8

p11

p12

p10

p13

p14

Fig. 9 A sample computation of the swarm routing illustrating the navigation process


resolving and navigation is ﬁnished allowing that the
P
assignment starts again. p8 ¼ assigner2 þ i2½3nf2g sleepi
assigns the target 1 and the start position h5; 4i to the AGV
a2 The other members of kind assigner sleep because the
a1 is not chosen to be assigned and a3 is already assigned.
P
In the next step, the rule p9 ¼ resolver4 þ i2½5nf4g sleepi
chooses a2 to move forward reserving the only possible
next edge for it. This step illustrates the behavior of a
member resolver in a situation where concurrent AGVs
having the same maximal priority and want to traverse the
assigned node. Namely one is chosen arbitrarily. Following
this decision, a2 moves forward and a3 waits augmenting
its priority by 1 as a result of the rule
p10 ¼ move2 þ wait3 þ sleep1 . The navigation rules yield
that a2 applies its arrive rule and that a3 waits again
because the next position is occupied, that is,
p11 ¼ arrive2 þ wait3 þ sleep1 . In the next two steps,
P
p12 ¼ resolver4 þ i2½5nf4g sleepi reserves the next posiP
tion for a3 followed by p13 ¼ move3 þ i2½2 sleepi which
moves it to the reserved position. In the last step, and
because the last active AGV a3 arrives at its target
P
p14 ¼ arrive3 þ i2½2 sleepi , the swarm reaches its goal.

5 Conclusion
In this paper, we have proposed to model dynamic logistic
networks with decentralized processing and control by
means of graph-transformational swarms. The members of
such a swarm act and interact in a common environment
graph. It is a rule-based approach, the semantics of which is
based on massive parallelism according to local control
conditions of the members and a global cooperation condition of the swarm as a whole. As we have discussed
above, this corresponds to dynamic logistic networks with
their logistic hubs and their processes which run simultaneously and autonomously with a proper way of coordination. We have sketched how automated guided vehicles
and their routing can be modeled by a graph-transformational swarm as an illustrative example. In this example,
we have demonstrated the capability of the approach
regarding visualization in the design level as well as the
computation level. Furthermore, we have provided two
theorems using the advantage of the formal semantics of
graph-transformational swarms. In order to shed more light
on the signiﬁcance of the approach, we will study the
following topics in future research.
1.

More case studies are needed including real applications. This would allow one to test the implementation
of a logistic network against a formal speciﬁcation by
means of graph-transformational swarms rather than

123

Logist. Res. (2016) 9:20

2.

3.

against informal or semiformal models or just against
the intuition of the designers.
The use of tools must be made more comfortable. At
the moment, one must adapt each graph-transformational swarm separately by hand to simulate and
visualize it on a graph-transformational engine or to
verify properties on a SAT-solver. By ﬁxing the
syntactic features of swarm modeling, one can construct translators into the tools so that the tools run
automatically on swarms and simulate and verify
logistic networks in this way.
It may be meaningful to translate the modeling
concepts of graph-transformational swarms into
explicit modeling concepts of dynamic logistic networks. In this way, modelers of networks do not need
to make themselves familiar with the swarm ideas, and
they could follow their intentions directly within the
ediﬁce of ideas of logistic networks.
